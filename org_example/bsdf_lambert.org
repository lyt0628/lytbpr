

We use the same code structure as [[./ray_triangle_intersection.org]].
We modify test_ray_triangle_intersection() method for geting the point of intersection and normal of surface.
See [[compute_wight_coordinate_of_projection_of_point]]


We get the position for computing the thrink of enege.
We prepare two variable L and L_c. L is the position of Light(A Point Light), and L_c is
Color of Light.

In setting color of image, we not just set it as Red, but Compute color form Light and two major
principle.
1. The Enege is thrink by 1/ r^2 to distance.
2. In Ligter hit into surface, only cosine of light particle recived by the surface.


Lambert assume all the surface are same, With a Constant factor and above principle, lambert
model is complete.
See [[compute_color_and_set_as_pixel]].

The rendered result like:


[[file:../example/triangle_lambert.ppm]]




* Main Code Block
#+BEGIN_SRC lua :tangle ../example/bsdf_lambert.lua
  package.path = package.path .. ";" .. "../src/util/?.lua"
  local Vec = require("vec")
  local Mat = require("mat")
  local PPM = require("ppm")

  <<FN:test_ray_trangle_intersection>>

  local img = PPM.new(64, 64)

  -- Light And Its Color
  local L = Vec.new(0, 0, 0)
  local L_c = Vec.new(255, 200, 100)

  -- A factor to modify light value
  local lambert_factor = Vec.new(36, 36, 36)

  local P = Vec.new(-1, 0, 0)
  local A = Vec.new(1, -32, 31)
  local B = Vec.new(6, 1, 5)
  local C = Vec.new(1, 24, 20)

  directions = {}
  <<prepare_directions_pointer_to_pixels_in_near_plane>>
  <<render_img_with_color_if_ray_hit_triangle>>

  img:save("triangle_lambert.ppm")
#+END_SRC


#+NAME: prepare_directions_pointer_to_pixels_in_near_plane
#+BEGIN_SRC lua
  for z = -32, 31 do
    for y = -32, 31 do
       table.insert(directions, Vec.new(1, y, z))
    end
  end
#+END_SRC

#+NAME: render_img_with_color_if_ray_hit_triangle
#+BEGIN_SRC lua
  for r = 1, 64 do
    for c = 1, 64 do
       local inside, Q, N = test_ray_triangle_intersection(P, directions[r + (c-1)*64 ],A,B,C)
       if (inside) then
          <<compute_color_and_set_as_pixel>>
       end
    end
  end
#+END_SRC


#+NAME: compute_color_and_set_as_pixel
#+BEGIN_SRC lua
  local distance_to_light = #(Q-L)
  print("Distance:" .. distance_to_light)
  local L_i = L_c / ( distance_to_light^2) * 15
  print("L_i:" .. L_i:r(),L_i:g(),L_i:b() )
  N = N:normlized()
 -- print("N: " .. N[1], N[2], N[3] ,#N)
  local D =  (Q-L):normlized()
 -- print("D: " .. D[1], D[2], D[3])
 -- print("Dot:" .. N:dot(D))
  local L_o = L_i * lambert_factor * math.max(0, N:dot(D))
 -- print("Output Color:" .. L_o[1],L_o[2],L_o[3] )
  img:set(r, c, L_o)
#+END_SRC


* FN:test_ray_trangle_intersection
#+NAME: FN:test_ray_trangle_intersection
#+BEGIN_SRC lua
  function test_ray_triangle_intersection(P, d, A, B, C)
        <<compute_normal_of_trangle_plane>>
        <<compute_axis_of_wight_coordinate>>
        <<sure_the_vectex_with_wight_coordinate_identity>>
        <<check_if_direction_of_ray_oppsite_to_plane>>
        <<compute_wight_coordinate_of_projection_of_point>>
  end
#+END_SRC

** Compute Normal of Trangle Plane
#+NAME: compute_normal_of_trangle_plane
#+BEGIN_SRC lua
  local AB = B - A
  local AC = C - A
  local N = Vec.cross3(AB, AC)
#+END_SRC

** Compute Axis of Wight Coordinate
#+NAME: compute_axis_of_wight_coordinate
#+BEGIN_SRC lua
  local AB_o = Vec.cross3(N, AB)
  local AC_o = Vec.cross3(N, AC)
#+END_SRC
** Sure The Vertex With Wight Coordinate identity
#+NAME: sure_the_vectex_with_wight_coordinate_identity
#+BEGIN_SRC lua
  local AB_o = AB_o / (AC:dot(AB_o))
  local AC_o = AC_o / (AB:dot(AC_o))
#+END_SRC

** Check If Direction Of Ray Oppsite to Plane
#+NAME: check_if_direction_of_ray_oppsite_to_plane
#+BEGIN_SRC lua
  local u = N:dot(d)

  if(u == 0) then
   -- print("Ray parall with Plane")
    return false
  end

  if math.abs(u) < 1e-15 then
   -- print("Unstable")
    return false
  end


  t = ((A-P):dot(N))/u

  if t < 0 then
   -- print("Ray miss plane")
    return false
  end


#+END_SRC
** Compute Wight Coordinate Of Projection Of Point
#+NAME: compute_wight_coordinate_of_projection_of_point
#+BEGIN_SRC lua 
  local Q = P + t * d

  local c = (Q - C):dot(AC_o)
  local b = (Q - B):dot(AB_o)
  local a = 1 - (b + c)

  if a < 0 or a > 1 or b < 0 or b > 1 or c < 0 or c > 1 then
   -- print("Out of triangle,", a, b, c)
    return false

  else
    print("Inside triangle,", a, b, c)

    -- Return a Extra Position of Intersection Point
    return true, Q, N
  end
#+END_SRC
