

We use the same code structure as [[./ray_triangle_intersection.org]].
We modify test_ray_triangle_intersection() method for geting the point of intersection and normal of surface.
See [[compute_wight_coordinate_of_projection_of_point]]


We get the position for computing the thrink of enege.
We prepare two variable L and L_c. L is the position of Light(A Point Light), and L_c is
Color of Light.

In setting color of image, we not just set it as Red, but Compute color form Light and two major
principle.
1. The Enege is thrink by 1/ r^2 to distance.
2. In Ligter hit into surface, only cosine of light particle recived by the surface.


Lambert assume all the surface are same, With a Constant factor and above principle, lambert
model is complete.
See [[compute_color_and_set_as_pixel]].

The rendered result like:


[[file:../example/triangle_lambert.ppm]]


+y Down
+z Depth
+x


* Main Code Block
#+BEGIN_SRC lua :tangle ../example/bsdf_lambert.lua
  package.path = package.path .. ";" .. "../src/util/?.lua"
  local Vec = require("vec")
  local Mat = require("mat")
  local PPM = require("ppm")


  local img = PPM.new(512, 512)

  -- Light And Its Color
  local L = Vec.new(0, 0, 0)
  local L_c = Vec.new(255, 200, 100)

  -- A factor to modify light value
  local lambert_bsdf = Vec.new(36, 36, 36) * 3500000

  local P = Vec.new(-1, 0, 0)
  local A = Vec.new(10, -1700, 1550)
  local B = Vec.new(60, 250, 500)
  local C = Vec.new(10, 1200, 1000)

  local AB = B - A
  local AC = C - A
  local N = Vec.cross3(AB, AC):normalized()

  local AB_o = Vec.cross3(N, AB)
  AB_o = AB_o / (AC:dot(AB_o))
  local AC_o = Vec.cross3(N, AC)
  AC_o = AC_o / (AB:dot(AC_o))


  <<FN:test_ray_trangle_intersection>>
  
  <<prepare_directions_pointer_to_pixels_in_near_plane>>
  <<render_img_with_color_if_ray_hit_triangle>>

  img:save("triangle_lambert.ppm")
#+END_SRC



* FN:test_ray_trangle_intersection
#+NAME: FN:test_ray_trangle_intersection
#+BEGIN_SRC lua
  function test_ray_triangle_intersection(P, d, A, N)
        <<check_if_direction_of_ray_oppsite_to_plane>>
        <<compute_wight_coordinate_of_projection_of_point>>
  end
#+END_SRC

** Check If Direction Of Ray Oppsite to Plane
#+NAME: check_if_direction_of_ray_oppsite_to_plane
#+BEGIN_SRC lua
  local u = N:dot(d)

  if(u == 0) then
   -- print("Ray parall with Plane")
    return false
  end

  if math.abs(u) < 1e-15 then
   -- print("Unstable")
    return false
  end


  t = ((A-P):dot(N))/u

  if t < 0 then
   -- print("Ray miss plane")
    return false
  end


#+END_SRC
** Compute Wight Coordinate Of Projection Of Point
#+NAME: compute_wight_coordinate_of_projection_of_point
#+BEGIN_SRC lua 
  local Q = P + t * d

  local c = (Q - C):dot(AC_o)
  local b = (Q - B):dot(AB_o)
  local a = 1 - (b + c)

  if a < 0 or a > 1 or b < 0 or b > 1 or c < 0 or c > 1 then
   -- print("Out of triangle,", a, b, c)
    return false

  else
    print("Inside triangle,", a, b, c)

    -- Return a Extra Position of Intersection Point
    return true, Q
  end
#+END_SRC


* Draw

** Compute Directions
#+NAME: prepare_directions_pointer_to_pixels_in_near_plane
#+BEGIN_SRC lua
  local directions = {}
  for z = -256, 255 do
    for y = -256, 255 do
       table.insert(directions, Vec.new(1, y, z))
    end
  end
#+END_SRC

** Rener Wtih lamert BSDF Sample

#+NAME: render_img_with_color_if_ray_hit_triangle
#+BEGIN_SRC lua
  for r = 1, 512 do
    for c = 1, 512 do
       local inside, Q = test_ray_triangle_intersection(P, directions[r + (c-1) * 512 ], A, N)
       if inside then
          <<compute_color_and_set_as_pixel>>
       end
    end
  end
#+END_SRC


#+NAME: compute_color_and_set_as_pixel
#+BEGIN_SRC lua
  local distance_to_light = #(Q-L)

  local L_i = L_c / (4 * math.pi * distance_to_light^2) 
  print("L_i:", L_i:r(), L_i:g(), L_i:b() )

  local D =  (Q-L):normalized()

  local L_o = L_i * lambert_bsdf * math.max(0, N:dot(D))
  print("L_o:", L_o[1],L_o[2],L_o[3] )
  img:set(r, c, L_o)
#+END_SRC

